'use strict';

var lr = require('@lezer/lr');
var language = require('@codemirror/language');
var highlight = require('@lezer/highlight');

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_Identifier = {__proto__:null,function:10, do:14, end:16, with:18, set:22, to:24, is:40, equals:42, "==":44, ">":48, "<":50, ">=":52, "<=":54, change:58, repeat:62, times:64, if:70, else:74, return:78};
const parser = lr.LRParser.deserialize({
  version: 14,
  states: "(dQYQPOOOOQO'#D`'#D`OOQO'#Ck'#CkO!QQPO'#CkOOQO'#Ci'#CiOOQO'#D_'#D_O!fQPO'#D_OOQO'#DU'#DUOOQO'#D['#D[OOQO'#DV'#DVQYQPOOO$VQPO'#C_O$[QPO'#CfO$aQPO'#CxO$fQPO'#C}O!QQPO'#DOO!QQPO'#DSO$mQPO,59VO!QQPO,59UO!QQPO,59_OOQO-E7T-E7TO$rQPO,58yO$zQPO,59QO%PQPO,59dO%UQPO'#CbO%]QPO,59fOOQO,59i,59iO%bQPO,59jOOQO,59n,59nOOQO1G.q1G.qOOQO1G.p1G.pOOQO1G.y1G.yOOQO1G.e1G.eO%gQPO1G.eO!QQPO1G.lO!QQPO1G/OO%lQPO,58|OOQO,58|,58|O%sQPO1G/QO%xQPO1G/UOOQO1G/U1G/UO&SQPO'#D]O%sQPO7+$POOQO7+$W7+$WOOQO7+$j7+$jOOQO1G.h1G.hOOQO7+$l7+$lO&[QPO7+$pO%sQPO'#DQOOQO7+$p7+$pO&fQPO'#DWO&kQPO,59wOOQO<<Gk<<GkOOQO<<H[<<H[OOQO,59l,59lOOQO,59r,59rOOQO-E7U-E7U",
  stateData: "&z~O}OSPOS~OSQOTZOZ[O`QOaQObPOcPOm]Oo^Os_Ow`O!TRO~OSQO`QOaQObPOcPO!TRO~OdbOebOfbOhcOicOjcOkcOS!RXT!RXZ!RX`!RXa!RXb!RXc!RXm!RXo!RXs!RXw!RX{!RX!T!RX!U!RXp!RXV!RXW!RXu!RX~OSeO~OSfO~OSgO~OVhO~P!QO!UmO~OVhOXqO~O[rO~O[sO~OWuO~PYOpvO~OVwO~OSyO~OW}O~PYOVhO~OWuOu!QO~PYO!Q!SOV!PX~OW}Ou!QO~PYOS!XO~O!Q!SOV!Pa~O`Sacba~",
  goto: "%e!TPPP!UPP!^PPP!UPP!p#O#^PPPPPPP#OPPPP!UP!UPP!U!UP#rP!UP!U#x$WPPP$^$fP$i%T]WOYhtw!PQj^QpeQxkQ!OvQ!UzR!W!QiTORY^_`hrstw!PiSORY^_`hrstw!PhUORY^_`hrstw!PQnbRocQ!RwR!V!PQYOUdYt!PQthR!PwQ!TyR!Y!T]XOYhtw!PRzq[VOYhtw!PQaRQi^Qk_Ql`Q{rR|smQORY^_`bchrstw!P",
  nodeNames: "âš  LineComment Program FunctionDefinition Identifier function Body do end with VariableDefinition set to BinaryExpression EqualityExpression PrimaryExpression Boolean String Integer Floating is equals == RelationalExpression > < >= <= VariableReassignment change RepeatStatement repeat times RepeatUntilGameOverStatement IfStatement if ElseStatement else ReturnStatement return ExpressionStatement",
  maxTerm: 52,
  skippedNodes: [0,1],
  repeatNodeCount: 2,
  tokenData: "*]~RgX^!jpq!jrs#_xy${yz%Q|}%V}!O%[!P!Q%{!Q![%b!c!}&j#T#Y&j#Y#Z&{#Z#h&j#h#i)]#i#o&j#y#z!j$f$g!j#BY#BZ!j$IS$I_!j$I|$JO!j$JT$JU!j$KV$KW!j&FU&FV!j~!oY}~X^!jpq!j#y#z!j$f$g!j#BY#BZ!j$IS$I_!j$I|$JO!j$JT$JU!j$KV$KW!j&FU&FV!j~#bVOr#_rs#ws#O#_#O#P#|#P;'S#_;'S;=`$u<%lO#_~#|Oa~~$PRO;'S#_;'S;=`$Y;=`O#_~$]WOr#_rs#ws#O#_#O#P#|#P;'S#_;'S;=`$u;=`<%l#_<%lO#_~$xP;=`<%l#_~%QO!T~~%VO!U~~%[O!Q~~%_P!Q![%b~%gQb~!O!P%m!Q![%b~%pP!Q![%s~%xPc~!Q![%s~&OP!P!Q&R~&WSP~OY&RZ;'S&R;'S;=`&d<%lO&R~&gP;=`<%l&R~&oSS~!Q![&j!c!}&j#R#S&j#T#o&j~'QTS~!Q![&j!c!}&j#R#S&j#T#U'a#U#o&j~'fUS~!Q![&j!c!}&j#R#S&j#T#`&j#`#a'x#a#o&j~'}US~!Q![&j!c!}&j#R#S&j#T#g&j#g#h(a#h#o&j~(fUS~!Q![&j!c!}&j#R#S&j#T#X&j#X#Y(x#Y#o&j~)PS`~S~!Q![&j!c!}&j#R#S&j#T#o&j~)bUS~!Q![&j!c!}&j#R#S&j#T#f&j#f#g)t#g#o&j~)yUS~!Q![&j!c!}&j#R#S&j#T#i&j#i#j(a#j#o&j",
  tokenizers: [0],
  topRules: {"Program":[0,2]},
  specialized: [{term: 4, get: (value) => spec_Identifier[value] || -1}],
  tokenPrec: 265
});

const jikiscriptLanguage = language.LRLanguage.define({
    name: "jikiscript",
    parser: parser.configure({
        props: [
            highlight.styleTags({
                String: highlight.tags.string,
                Boolean: highlight.tags.bool,
                LineComment: highlight.tags.lineComment,
                Integer: highlight.tags.number,
                Floating: highlight.tags.float,
                "do end": highlight.tags.keyword,
                "set change to": highlight.tags.keyword,
                "function with": highlight.tags.definitionKeyword,
                "repeat repeat_until_game_over times": highlight.tags.keyword,
                "if else": highlight.tags.keyword,
                "is equals": highlight.tags.keyword,
                "return": highlight.tags.keyword,
                Identifier: highlight.tags.variableName,
                ArgumentList: highlight.tags.variableName,
                "( )": highlight.tags.paren
                /*
                "( )": t.paren,
                "[ ]": t.squareBracket,
                "{ }": t.brace,
                Escape: t.escape,
                Identifier: t.function(t.definition(t.variableName)),
                Signature: t.meta,
                Glyph: t.atom,*/
            }),
            language.indentNodeProp.add({
                FunctionDefinition: context => {
                    return context.lineIndent(context.node.from) + context.unit; // Indent for function body
                },
                IfStatement: context => {
                    return context.lineIndent(context.node.from) + context.unit; // Indent for function body
                },
                ElseStatement: context => {
                    return context.lineIndent(context.node.from) + context.unit; // Indent for function body
                },
                statement: context => context.lineIndent(context.node.from) + context.unit, // Indent for nested statements
                EndStatement: context => context.lineIndent(context.node.from), // Reset for end statements
            }),
            language.foldNodeProp.add({
                FunctionDefinition: language.foldInside, // Allow folding of function blocks
                IfStatement: language.foldInside, // Allow folding of function blocks
            }),
        ],
    }),
    // languageData: {
    //   closeBrackets: { brackets: ["(", "[", "do", '"'] },
    //   commentTokens: { line: "//" },
    // },
});
function jikiscript() {
    return new language.LanguageSupport(jikiscriptLanguage);
}

exports.jikiscript = jikiscript;
exports.jikiscriptLanguage = jikiscriptLanguage;
