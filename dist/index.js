import { LRParser } from '@lezer/lr';
import { LRLanguage, indentNodeProp, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';
import { styleTags, tags } from '@lezer/highlight';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_Identifier = {__proto__:null,log:10, new:26, is:50, equals:52, and:58, or:60, not:82, function:86, do:88, end:90, with:92, set:96, to:98, change:102, repeat:108, times:110, indexed:114, by:116, repeat_until_game_over:120, repeat_forever:124, for:128, each:130, in:132, if:136, else:138, return:142, continue:146, next:150, break:154};
const parser = LRParser.deserialize({
  version: 14,
  states: "5YQYQPOOO!ZQPO'#ClOOQO'#D|'#D|OOQO'#EV'#EVOOQO'#D}'#D}QYQPOOQ!`QPO'#EUO!eQPO'#C_O#YQPO'#DWO#_QPO'#D]O#dQPO'#D`O!eQPO'#DcO#iQPO'#DiO#iQPO'#DkO#qQPO'#DmO!eQPO'#DqO!eQPO'#DtOOQO'#Dv'#DvOOQO'#Dx'#DxOOQO'#Dz'#DzOOQO'#EU'#EUO#vQPO,59WOOQO-E7{-E7{OOQO,5:p,5:pO!eQPO'#CgO$oQQO'#CdO%rQPO'#CoO%yQPO'#CpOOQO'#E^'#E^OOQO'#Cd'#CdO&UQQO'#CbOOQO'#EW'#EWO!eQPO'#DUOOQO'#Cb'#CbO'rQPO'#ChOOQO,58y,58yO'wQPO,59rO(PQPO,59wO(UQPO,59zO(^QPO,59}O(cQPO'#EjO(hQPO'#DfOOQO,5:T,5:TO(mQPO,5:TOOQO,5:V,5:VO(mQPO,5:VO(rQPO,5:XO(wQPO,5:]OOQO,5:`,5:`O(|QPO'#EXOOQO1G.r1G.rO)UQPO1G.rO)ZQPO,59ROOQO,59Z,59ZO)`QPO,59ZOOQO,59[,59[O)hQPO,59[O)sQPO,59[OOQO'#Cw'#CwO*dQPO,58}OOQO'#C{'#C{OOQO'#C|'#C|OOQO'#C}'#C}OOQO'#DO'#DOOOQO'#DP'#DPOOQO'#DQ'#DQOOQO'#DS'#DSOOQO'#DT'#DTO!eQPO,59dOOQO,59p,59pO*kQPO,59SOOQO1G/^1G/^O*pQPO1G/^O!eQPO1G/cO!eQPO1G/fO*uQPO1G/hO#iQPO1G/iO*zQPO,5;UO+RQPO,5:QOOQO1G/o1G/oOOQO1G/q1G/qO+WQPO1G/sO+]QPO'#EjOOQO1G/w1G/wO!eQPO'#EOO+bQPO,5:sOOQO7+$^7+$^OOQO1G.m1G.mO+jQPO1G.uOOQO1G.u1G.uOOQO1G.v1G.vO+rQPO1G.vO+wQPO1G.vO!eQPO1G.vO#}QPO'#CdOOQO1G.i1G.iOOQO1G/O1G/OO+|QPO1G.nO,TQPO'#EkO(mQPO7+$xOOQO7+$}7+$}OOQO7+%Q7+%QO!eQPO7+%SOOQO7+%T7+%TO(mQPO7+%TO,]QPO1G0pOOQO1G0p1G0pOOQO1G/l1G/lO!eQPO7+%_O,dQPO,5;UOOQO,5:j,5:jOOQO-E7|-E7|OOQO7+$a7+$aOOQO7+$b7+$bO!eQPO7+$bO,nQPO7+$bOOQO7+$Y7+$YO,yQPO7+$YO-OQPO'#EQO-TQPO,5;VOOQO<<Hd<<HdOOQO<<Hn<<HnOOQO<<Ho<<HoOOQO7+&[7+&[O#iQPO<<HyO-]QPO1G0pO-gQPO1G0rO-oQPO<<G|O-zQPO'#EPO-oQPO<<G|OOQO<<G|<<G|O.SQPO<<G|OOQO<<Gt<<GtOOQO,5:l,5:lOOQO-E8O-E8OOOQOAN>eAN>eO(mQPOAN>eO-gQPO7+&^OOQO7+&^7+&^O.XQPOAN=hOOQOAN=hAN=hO.dQPOAN=hO.iQPO,5:kO.nQPO,5:kOOQO-E7}-E7}OOQOG24PG24POOQO<<Ix<<IxOOQOG23SG23SO.sQPOG23SO!eQPO1G0VO.xQPO1G0VOOQOLD(nLD(nOOQO7+%q7+%qO!eQPO7+%qOOQO<<I]<<I]",
  stateData: "/W~O!wOSPOS~OSPOTVO{WO!QXO!TYO!WZO!^[O!`]O!b^O!f_O!i`O!kaO!mbO!ocO#OdO~OYeO~O#OgO~OSiOYhO]rObjOemOfmOglOhlOypO!}kO#]pO~OStO~OSuO~OSvO~O|xO!ZyO~O!c!OO~OX!SO~P!eOYeO!uWX#OWX!XWX|WXXWX_WXaWX!|WX!ZWX~OiWXjWXmWXnWXuWX#RWX#SWX#TWX#UWX#VWX#WWX#XWX#YWX#ZWX#[WX~P#}Oa!VO~P!eOe!ZO!|!XO#O!YO~Oi!]Oj!]Om!fOn!fOu!fO#R![O#S![O#T!^O#U!_O#V!`O#W!aO#X!bO#Y!cO#Z!dO#[!eO!uUX#OUX!XUX|UXXUX_UXaUX!|UX!ZUX~O^!hO~O|xO!O!jO~O!R!kO~ObjO!R!lO~O!X!nO~O#O!oO~O![!pO~O|xO~OS!sO~O|!tO~O_!vOX!{X~OX!xO~OX!yO~O_!vOa!{O~Oe#OO!|!|O#O!}O~O#P#PO~OYhO]rObjOemOfmOglOhlO!}kO~OS#QO~P)xOY#TO~OS#UO~O!R#YO~O}#^O~PYOS#_O~O!d#`O~O#O#aO~O_!vOX!{a~O_!vOa#dO~O!|#eO~O#P#fO~OX#hO~P!eO_#jO|#_X~O}#oO~PYO}#^O!g#rO~PYO_#tO!|#vO#O#wO~OX#xO~OS#yO~O_#jO|#_a~O}#oO!g#}O~PYO|xO!f_O~O_#tO!|$QO#O$RO~Oe$SO#O$TO~O!|$QO~O_#tO!|$XO#O$YO~O!|$XO~O#P$ZO~Oe$[O~O!|$]O~O#P$_O~OPhgufSeu~",
  goto: "*y#aPPP#bPP#j$s%YPP%r%rPPP&YPP&x%rPPPPPP'c$sPP'f'f'f'f'f'fP'f'f'iP#bPPPP#bPP#bP#b#bPP(OPP#bP#bP#bPPP([PP#bP#bP#bP#bP#b(j(x)S)^PPP)d)l'i)tPPPP%rPPPPPPPPPPP)z*s*v]ROT!o#]#a#qQsVQwZQ!P_Q!Q`S!Re#TQ!UhQ!WjQ!gpQ#S!fQ#W!kQ#X!lQ#b!vQ#g#PQ#m#YQ#p#`Q#s#fQ$^$ZR$`$_woVZ_`ehjp!f!k!l!v#P#T#Y#`#f$Z$_vnVZ_`ehjp!f!k!l!v#P#T#Y#`#f$Z$_R#R!]ymVZ_`ehjp!]!f!k!l!v#P#T#Y#`#f$Z$_[QOT!o#]#a#qymVZ_`ehjp!]!f!k!l!v#P#T#Y#`#f$Z$_xmVZ_`ehjp!]!f!k!l!v#P#T#Y#`#f$Z$_R!mvR!]nR!fnwqVZ_`ehjp!f!k!l!v#P#T#Y#`#f$Z$_Q{[Q}]Q#[!nR#|#p[ROT!o#]#a#qQ$O#rR$W#}QTOUfT#]#qQ#]!oR#q#aQ!w!RQ!z!WT#c!w!zQ#u#gQ$P#sT$U#u$PQ#k#UR#z#k]SOT!o#]#a#q]UOT!o#]#a#qQ!TeR#i#TQz[Q|]Q!itQ!q{Q!r}Q!u!PQ#Z!nQ#l#VQ#n#[Q#{#pQ$O#rQ$V#|R$W#}R#V!jR!u!P",
  nodeNames: "âš  LineComment Program LogStatement Identifier log Expression EqualityExpression PrimaryExpression ) ( GroupingExpression InstantiateExpression new ClassName , CallExpression ] [ ListExpression DictionaryExpression String Boolean Integer Floating is equals CompareOp RelationalExpression and or CompareOp CompareOp CompareOp CompareOp ArithOp ArithOp ArithOp ArithOp ArithOp UnaryExpression not FunctionDefinition function do end with SetVariableStatement set to ChangeVariableStatement change ChangeListElementStatement RepeatStatement repeat times IndexedByComponent indexed by RepeatUntilGameOverStatement repeat_until_game_over RepeatForeverStatement repeat_forever ForeachStatement for each in IfStatement if else ReturnStatement return ContinueStatement continue NextStatement next BreakStatement break CallStatement",
  maxTerm: 108,
  nodeProps: [
    ["openedBy", 9,"(",17,"["],
    ["closedBy", 10,")",18,"]"]
  ],
  skippedNodes: [0,1],
  repeatNodeCount: 4,
  tokenData: ",c~RkYZ!vpq!{qr#Qrs#_uv${xy%Qyz%Vz{%[{|%a|}%f}!O%k!P!Q&^!Q![%s![!]&}!^!_'S!_!`'a!`!a'l!c!}'y!}#O([#P#Q(a#T#Y(f#Y#Z(w#Z#h(f#h#i+X#i#o(f#o#p,X#q#r,^~!{O#O~~#QO!w~R#VP#]P!_!`#YQ#_O#SQ~#bVOr#_rs#ws#O#_#O#P#|#P;'S#_;'S;=`$u<%lO#_~#|Oe~~$PRO;'S#_;'S;=`$Y;=`O#_~$]WOr#_rs#ws#O#_#O#P#|#P;'S#_;'S;=`$u;=`<%l#_<%lO#_~$xP;=`<%l#_~%QO#[~~%VOY~~%[OX~~%aO#X~~%fO#Y~~%kO_~R%pP#ZQ!Q![%sP%xQgP!O!P&O!Q![%sP&RP!Q![&UP&ZPhP!Q![&U~&cPu~!P!Q&f~&kSP~OY&fZ;'S&f;'S;=`&w<%lO&f~&zP;=`<%l&f~'SO#P~~'XP#U~!_!`'[~'aO#W~~'dP!_!`'g~'lO#R~~'qP#T~!_!`'t~'yO#V~~(OS^~!Q!['y!c!}'y#R#S'y#T#o'y~(aOb~~(fOa~~(kSS~!Q![(f!c!}(f#R#S(f#T#o(f~(|TS~!Q![(f!c!}(f#R#S(f#T#U)]#U#o(f~)bUS~!Q![(f!c!}(f#R#S(f#T#`(f#`#a)t#a#o(f~)yUS~!Q![(f!c!}(f#R#S(f#T#g(f#g#h*]#h#o(f~*bUS~!Q![(f!c!}(f#R#S(f#T#X(f#X#Y*t#Y#o(f~*{Sf~S~!Q![(f!c!}(f#R#S(f#T#o(f~+^US~!Q![(f!c!}(f#R#S(f#T#f(f#f#g+p#g#o(f~+uUS~!Q![(f!c!}(f#R#S(f#T#i(f#i#j*]#j#o(f~,^O!}~~,cO!|~",
  tokenizers: [0, 1],
  topRules: {"Program":[0,2]},
  specialized: [{term: 4, get: (value) => spec_Identifier[value] || -1}],
  tokenPrec: 643
});

const addIndent = (context) => context.lineIndent(context.node.from) + context.unit; // Indent for function body
const removeIndent = (context) => context.lineIndent(context.node.from);
const jikiscriptLanguage = LRLanguage.define({
    name: "jikiscript",
    parser: parser.configure({
        strict: false, // Toggle for sanity!
        props: [
            styleTags({
                String: tags.string,
                Boolean: tags.bool,
                LineComment: tags.lineComment,
                Integer: tags.number,
                Floating: tags.float,
                "repeat times repeat_until_game_over repeat_forever": tags.controlKeyword,
                "if else do end log": tags.controlKeyword,
                "for each in": tags.controlKeyword,
                "new": tags.controlKeyword,
                "with to indexed by": tags.controlKeyword,
                "next break continue": tags.controlKeyword,
                "return": tags.controlKeyword,
                "function set change": tags.definitionKeyword,
                "and or is equals not": tags.logicOperator,
                ArithOp: tags.arithmeticOperator,
                CompareOp: tags.compareOperator,
                "> < >= <= ==": tags.operator,
                bangOperator: tags.operator,
                UnaryExpression: tags.operator,
                Identifier: tags.variableName,
                ClassName: tags.className,
                ArgumentList: tags.variableName,
                "( ) ,": tags.paren,
                "[ ]": tags.squareBracket
            }),
            indentNodeProp.add({
                FunctionDefinition: addIndent,
                IfStatement: addIndent,
                ElseStatement: addIndent,
                RepeatStatement: addIndent,
                RepeatUntilGameOverStatement: addIndent,
                statement: addIndent, // Indent for nested statements
                EndStatement: removeIndent, // Reset for end statements
            }),
            foldNodeProp.add({
                FunctionDefinition: foldInside, // Allow folding of function blocks
                IfStatement: foldInside, // Allow folding of function blocks
            }),
        ],
    })
    // languageData: {
    //   closeBrackets: { brackets: ["(", "[", "do", '"'] },
    // }
    //   commentTokens: { line: "//" },
    // },
});
function jikiscript() {
    return new LanguageSupport(jikiscriptLanguage);
}
const jikiscriptStrict = LRLanguage.define({
    name: "jikiscriptStrict",
    parser: parser.configure({
        strict: true,
    }),
});

export { jikiscript, jikiscriptLanguage, jikiscriptStrict };
