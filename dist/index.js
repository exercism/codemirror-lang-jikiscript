import { LRParser } from '@lezer/lr';
import { LRLanguage, indentNodeProp, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';
import { styleTags, tags } from '@lezer/highlight';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_Identifier = {__proto__:null,log:10, is:42, equals:44, and:50, or:52, not:74, function:80, do:82, end:84, with:86, set:90, to:92, change:96, repeat:102, times:104, repeat_until_game_over:108, repeat_forever:112, for:116, each:118, in:120, if:124, else:126, return:130};
const parser = LRParser.deserialize({
  version: 14,
  states: ".|QYQPOOO!QQPO'#ChOOQO'#Dp'#DpOOQO'#Dx'#DxOOQO'#Dq'#DqQYQPOOQ!VQPO'#DwO![QPO'#C_O!vQPO'#DTO!{QPO'#DYO#QQPO'#D]O![QPO'#D`O#VQPO'#DcO#VQPO'#DeO#[QPO'#DgO![QPO'#DkO![QPO'#DnOOQO'#Dw'#DwO#aQPO,59SOOQO-E7o-E7oOOQO,5:c,5:cO![QPO'#CgO$VQQO'#CdO%YQPO'#ClOOQO'#D{'#D{OOQO'#Cd'#CdO%aQQO'#CbOOQO'#Dy'#DyOOQO'#Cb'#CbO![QPO'#DQOOQO,58y,58yO&zQPO,59oO'SQPO,59tO'XQPO,59wO'aQPO,59zO'fQPO'#EWOOQO,59},59}OOQO,5:P,5:PO'kQPO,5:RO'pQPO,5:VOOQO,5:Y,5:YO'uQPO'#DzOOQO1G.n1G.nO'}QPO1G.nO(SQPO,59ROOQO,59W,59WO(XQPO,59WOOQO'#Cs'#CsO(uQPO,58}OOQO'#Cw'#CwOOQO'#Cx'#CxOOQO'#Cy'#CyOOQO'#Cz'#CzOOQO'#C{'#C{OOQO'#C|'#C|OOQO'#DO'#DOOOQO'#DP'#DPO![QPO,59`O(|QPO,59lOOQO1G/Z1G/ZO)RQPO1G/ZO![QPO1G/`O![QPO1G/cO)WQPO1G/eO#VQPO1G/fO)]QPO,5:rO)dQPO1G/mO)iQPO'#EWOOQO1G/q1G/qO![QPO'#DrO)nQPO,5:fOOQO7+$Y7+$YOOQO1G.m1G.mO)vQPO1G.rOOQO1G.r1G.rO#hQPO'#CdOOQO1G.i1G.iOOQO1G.z1G.zO![QPO1G/WO*OQPO'#EYO#VQPO7+$uOOQO7+$z7+$zOOQO7+$}7+$}O![QPO7+%POOQO7+%Q7+%QO*WQPO1G0^OOQO1G0^1G0^O![QPO7+%XO*_QPO,5:rOOQO,5:^,5:^OOQO-E7p-E7pOOQO7+$^7+$^OOQO7+$r7+$rO*iQPO'#DsO*nQPO,5:tOOQO<<Ha<<HaOOQO<<Hk<<HkOOQO7+%x7+%xO#VQPO<<HsO*vQPO1G0^O+QQPO1G0aOOQO,5:_,5:_OOQO-E7q-E7qOOQOAN>_AN>_O+QQPO7+%{OOQO7+%{7+%{OOQO<<Ig<<Ig",
  stateData: "+c~O!jOSPOS~OSPOTVOxWO}XO!QYO!TZO!W[O!Y]O![^O!`_O!c`O!{aO~OYbO~O!{dO~OSfOYeO_gOaiObiOchOdhOumO~OSoO~OSpO~OSqO~OysO~O!]vO~OXzO~P![OYbO!hWX!{WX!UWXyWXXWX]WX^WXvWX~OeWXfWXiWXjWXqWX!pWX!qWX!rWX!sWX!tWX!uWX!vWX!wWX!xWX!yWX~P#hO^}O~P![Oe!QOf!QOi!ZOj!ZOq!ZO!p!PO!q!PO!r!RO!s!SO!t!TO!u!UO!v!VO!w!WO!x!XO!y!YO!hUX!{UX!UUXyUXXUX]UX^UXvUX~OysO{!^O~O!O!_O~O_gO!O!`O~O!U!bO~O!{!cO~OS!dO~Oy!eO~O]!gOX!nX~OX!iO~OX!jO~O]!gO^!lO~OYeO_gOaiObiOchOdhO~OS!mO~P(aOv!pO~OS!qO~O!O!uO~Oz!xO~PYO!^!yO~O!{!zO~O]!gOX!na~O]!gO^!}O~O]#POy!|X~Oz#TO~PYOz!xO!a#WO~PYOS#XO~O]#POy!|a~Oz#TO!a#[O~PYOysO!`_O~OPdcqaSbq~",
  goto: "(}#OPPP#PPP#X$W$iPP$}%aPPP%{PPPPPP&b$WPP&e&e&e&e&e&eP&e&e&hPP#PPPPP#PPP#PP#P#PPP#PP#PP#PPPP&yPP#PP#P'X'g'qPPP'w(P&h(X$}PPPPPPPPPP([P(w(z]ROT!c!w!z#VQnVQrZQw_Qx`QybQ|eQ!OgQ![mQ!o!ZQ!s!_Q!t!`Q!{!gQ#O!pQ#S!uR#U!yokVZ_`begm!Z!_!`!g!p!u!ynjVZ_`begm!Z!_!`!g!p!u!yR!n!QqiVZ_`begm!Q!Z!_!`!g!p!u!y[QOT!c!w!z#VqiVZ_`begm!Q!Z!_!`!g!p!u!ypiVZ_`begm!Q!Z!_!`!g!p!u!yR!aqR!QjR!ZjolVZ_`begm!Z!_!`!g!p!u!y[ROT!c!w!z#VQ#]#WR#^#[QTOUcT!w#VQ!w!cR#V!zQ!hyQ!k!OT!|!h!kQ#Q!qR#Y#Q]SOT!c!w!z#V]UOT!c!w!z#VR{bQt[Qu]Q!]oQ!fwQ!v!bQ#R!rQ#Z#UQ#]#WR#^#[R!r!^R!fw",
  nodeNames: "âš  LineComment Program LogStatement Identifier log Expression EqualityExpression PrimaryExpression ) ( GroupingExpression CallExpression , ] [ ListExpression Boolean String Integer Floating is equals CompareOp RelationalExpression and or CompareOp CompareOp CompareOp CompareOp ArithOp ArithOp ArithOp ArithOp ArithOp UnaryExpression not ! FunctionDefinition function do end with SetVariableStatement set to ChangeVariableStatement change ChangeListElementStatement RepeatStatement repeat times RepeatUntilGameOverStatement repeat_until_game_over RepeatForeverStatement repeat_forever ForeachStatement for each in IfStatement if else ReturnStatement return CallStatement",
  maxTerm: 91,
  nodeProps: [
    ["openedBy", 9,"(",14,"["],
    ["closedBy", 10,")",15,"]"]
  ],
  skippedNodes: [0,1],
  repeatNodeCount: 3,
  tokenData: "+h~RhYZ!mpq!rqr!wrs#Uuv$rxy$wyz$|z{%R{|%W|}%]}!O%b!P!Q&T!Q![%j!^!_&t!_!`'R!`!a'^!c!}'k!}#O'|#P#Q(R#T#Y'k#Y#Z(W#Z#h'k#h#i*h#i#o'k~!rO!{~~!wO!j~~!|Pv~!_!`#P~#UO!q~~#XVOr#Urs#ns#O#U#O#P#s#P;'S#U;'S;=`$l<%lO#U~#sOb~~#vRO;'S#U;'S;=`$P;=`O#U~$SWOr#Urs#ns#O#U#O#P#s#P;'S#U;'S;=`$l;=`<%l#U<%lO#U~$oP;=`<%l#U~$wO!y~~$|OY~~%ROX~~%WO!v~~%]O!w~~%bO]~R%gP!xQ!Q![%jP%oQcP!O!P%u!Q![%jP%xP!Q![%{P&QPdP!Q![%{~&YPq~!P!Q&]~&bSP~OY&]Z;'S&];'S;=`&n<%lO&]~&qP;=`<%l&]~&yP!s~!_!`&|~'RO!u~~'UP!_!`'X~'^O!p~~'cP!r~!_!`'f~'kO!t~~'pSS~!Q!['k!c!}'k#R#S'k#T#o'k~(RO_~~(WO^~~(]TS~!Q!['k!c!}'k#R#S'k#T#U(l#U#o'k~(qUS~!Q!['k!c!}'k#R#S'k#T#`'k#`#a)T#a#o'k~)YUS~!Q!['k!c!}'k#R#S'k#T#g'k#g#h)l#h#o'k~)qUS~!Q!['k!c!}'k#R#S'k#T#X'k#X#Y*T#Y#o'k~*[Sa~S~!Q!['k!c!}'k#R#S'k#T#o'k~*mUS~!Q!['k!c!}'k#R#S'k#T#f'k#f#g+P#g#o'k~+UUS~!Q!['k!c!}'k#R#S'k#T#i'k#i#j)l#j#o'k",
  tokenizers: [0, 1],
  topRules: {"Program":[0,2]},
  specialized: [{term: 4, get: (value) => spec_Identifier[value] || -1}],
  tokenPrec: 470
});

const addIndent = (context) => context.lineIndent(context.node.from) + context.unit; // Indent for function body
const removeIndent = (context) => context.lineIndent(context.node.from);
const jikiscriptLanguage = LRLanguage.define({
    name: "jikiscript",
    parser: parser.configure({
        strict: false, // Toggle for sanity!
        props: [
            styleTags({
                String: tags.string,
                Boolean: tags.bool,
                LineComment: tags.lineComment,
                Integer: tags.number,
                Floating: tags.float,
                "repeat times repeat_until_game_over repeat_forever": tags.controlKeyword,
                "if else do end log": tags.controlKeyword,
                "for each in": tags.controlKeyword,
                "with to": tags.controlKeyword,
                "return": tags.controlKeyword,
                "function set change": tags.definitionKeyword,
                "and or is equals not": tags.logicOperator,
                ArithOp: tags.arithmeticOperator,
                CompareOp: tags.compareOperator,
                "> < >= <= == !": tags.operator,
                Identifier: tags.variableName,
                ArgumentList: tags.variableName,
                "( ) ,": tags.paren,
                "[ ]": tags.squareBracket
            }),
            indentNodeProp.add({
                FunctionDefinition: addIndent,
                IfStatement: addIndent,
                ElseStatement: addIndent,
                RepeatStatement: addIndent,
                RepeatUntilGameOverStatement: addIndent,
                statement: addIndent, // Indent for nested statements
                EndStatement: removeIndent, // Reset for end statements
            }),
            foldNodeProp.add({
                FunctionDefinition: foldInside, // Allow folding of function blocks
                IfStatement: foldInside, // Allow folding of function blocks
            }),
        ],
    })
    // languageData: {
    //   closeBrackets: { brackets: ["(", "[", "do", '"'] },
    // }
    //   commentTokens: { line: "//" },
    // },
});
function jikiscript() {
    return new LanguageSupport(jikiscriptLanguage);
}
const jikiscriptStrict = LRLanguage.define({
    name: "jikiscriptStrict",
    parser: parser.configure({
        strict: true,
    }),
});

export { jikiscript, jikiscriptLanguage, jikiscriptStrict };
